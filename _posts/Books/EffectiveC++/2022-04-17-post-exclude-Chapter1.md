---
title: "Chapter1"
categories:
  - EffectiveCpp
classes : wide
tags:
  - C++
---

<h1>

- Chapter1 : C++에 왔으면 C++의 법을 따릅시다.

</h1>

<h2>
- C++를 언어들의 연합체로 바라보는 안목은 필수
</h2>

  - C, 객체 지향 개념의 C++, 템플릿 C++, STL 의 4가지 하위 언어들로 이루어져있다. 

  - C++를 사용한 효과적인 플그래밍 규칙은 경우에 따라 달라진다. 그 경우란, 바로 c++의 어떤 부분을 사용하느냐이다.

<br>

<h2>
- define을 쓰려거든 const, enum, inline을 떠올리자. (선행 처리자보다 컴파일러를 더 가까이하자)
</h2>

  - 단순한 상수를 쓸 떄는, #define보다 const 객체 혹은 enum을 우선으로 두자.
    - define 상수 값 (define FIVE = 5)은 컴파일러 입장에선 상수 그 자체(5)로만 보이기 때문에 에러 발생시 FIVE 대신 5로만 출력돼 후 유지보수가 힘들다.

    - define은 캡슐화 혜택을 받을 수 없다. 'private define'이란 없다. 해당 문제를 해결하는 방법으로는 '나열자 둔갑술'이 있다.
  
      - 나열자 둔갑술 : define을 사용하는대신 enum을 활용해 캡슐화 혜택을 받으며 주소 보안등 define의 장점을 가질 수 있다.
  
  - 매크로 함수는 inline 함수로 대체하자.
  
<br>

<h2>
- 낌새만 보이면 const를 들이대보자.
</h2>

  - const는 프로그래머의 의도를 명백히 알리고 실수를 줄여주는 역할을 한다.
    - const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는데 도움을 준다. 

  - 비트수준 상수성 

    -  어떤 맴버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야(정적 멤버는 제외) 그 멤버 함수가 'const'임을 인정하는 개념

    -  그러나 특정 방법을 이용하면 내부 값이 변경되는 구멍이 있다.

  - 논리적 상수정

    - 비트 수준 상수성과는 달리 일부 몇 비트는 바꿀 수 있되, 사용자측에서 알아채지 못하게만 하면 상수 멤버 자격을 인정하는 개념.

    - 비트 수준 상수성을 지원하는 c++에서 사용되기 위해선 'mutable' 키워드를 이용해 구현

  - 컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만, 프로그래머는 개념적인(논리적인) 상수성을 사용해서 프로그래밍해야 한다.

  - 상수 멤버 및 비 상수 멤버 함수가 기능적으로 서로 중복이라면 비상수 버전이 상수 버전을 호출하도록 만들자.

<br>

<h2>
- 객체를 사용하기 전에 반드시 그 객체를 초기화 하자
</h2>

- 기본제공 타입의 객체는 직접 손으로 초기화하자. 경우에 따라 저절로 되기도 하고 안 되기도 하기 때문

- 생성자에서는, 멤버 초기화 리스트를 즐겨 사용하자. 그리고 초기화 리스트에 데이터 멤버를 나열할때는 선언된 순서와 동일하게 나열하자.

- 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계해야 한다. 비지역 정적 객체를 지역 정적 객체로 바꿔 순서를 명시하자.
