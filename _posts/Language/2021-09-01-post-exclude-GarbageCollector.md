---
title: "GC (가비지 콜렉터)"
categories:
  - CSharp
tags:
  - GC (Garbage Collector)
---




  
<br>
<h1>
GC의 역할 
</h1>
<br>
  
  - 메모리 영역 중 힙 영역을 관리 한다.
  
  - C++ 에서는 동적할당된 변수의 동적해제는 프로그래머의 책임이다.  
    - 동적해제를 하지 않을 경우 메모리 누수가 발생한다.
 
<br>

  - 반면 C# 에서는 GC가 동적해제를 담당한다.

    - 그 이유로는 프로그래머가 메모리 영역에 관여 할 수 있다는 점은 성능면에서 우월하지만, 사람이기에 다양한 실수가 일어난다. 
    	- (동적해제된 메모리 참조, 동적해제를 하지않아 메모리 누수 발생 등)

	- 프로그래머가 메모리를 관리하는 것이 아닌 GC가 메모리를 관리함으로써 안정성을 얻을 수 있다.

	- GC는 힙 영역을 탐색하며 참조되지 않는 객체들을 동적해제한다.



<br>
<h1>
GC의 동작
</h1>
<br>

- GC는 (.Net의 GC 기준) 3가지의 세대로 나뉜다.

  - 0 세대
    - GC의 검사를 한번도 거치지 않은 이제 막 할당된 메모리들이 있는 구역 
  
  - 1 세대
    - GC의 검사를 한번 거친 메모리들이 있는 구역 

  - 2 세대
    - GC의 검사를 두번 거친 메모리들이 있는 구역 

<br>

- 이렇게 세대를 나눈 이유는 '새롭게 할당된 영역일 수록 빨리 해제 될 확률이 높다' 라는 규칙 떄문이다. 

  <br>
- GC의 작동 기준은 3가지가 있다.

  - full GC (하나의 영역이 가득 참) 

  - GC.Collect 메서드 호출 시

  - 시스템의 메모리가 부족할 때 
  
<br>
<br>
<h1>
STOP THE WORLD
</h1>

 - GC가 일련의 작업을 수행하는 동안, GC 스레드를 제외한 모든 스레드를 일시정지 시킨다.
   - 유니티에서 게임 끊김 현상의 이유 중 하나이다.
  
  <br>
<br>
<h1>
GC의 단점
</h1>

- GC 스레드를 제외한 모든 스레드를 일시정지 시킴으로 인하여 렉 현상이 발생한다.

   - 유니티에서 게임 끊김 현상의 이유 중 하나이다.
  
  <br>

- 프로그래머는 GC의 호출빈도를 줄이는 작업을 할 필요가 있다.

  - Full GC로인한 GC 호출을 피하기 위해 너무 많은 객체 할당을 피한다. 
  
  - 하나의 객체에 많은 참조관계를 두지 않도록 한다.
    -  많은 참조관계는 GC의 검사에서 살아남을 확률이 높고, GC가 검사할때마다 참조 관계를 모두 검사하기 때문에 오버헤드를 부른다.

   
        





  